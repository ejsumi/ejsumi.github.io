"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[7263],{3679(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var s=a(2601),t=a(4848),i=a(8453);const r={title:"Pandas GroupBy in Practice: Real-World Scenarios and What to Watch Out For",description:"Practical guide to GroupBy and aggregation using business scenarios \u2014 sales performance, campaign ROI, and support ticket analysis. Covers the gotchas learners commonly hit.",tags:["python","data analysis","learning"]},o=void 0,l={authorsImageUrls:[]},c=[{value:"Scenario 1: Sales Performance by Manager",id:"scenario-1-sales-performance-by-manager",level:2},{value:"Grouping by a single column",id:"grouping-by-a-single-column",level:3},{value:"Grouping by multiple columns",id:"grouping-by-multiple-columns",level:3},{value:"Aggregating multiple metrics at once",id:"aggregating-multiple-metrics-at-once",level:3},{value:"<code>as_index=False</code> \u2014 when do you need it?",id:"as_indexfalse--when-do-you-need-it",level:3},{value:"Scenario 2: Campaign ROI \u2014 Deriving Metrics After Aggregation",id:"scenario-2-campaign-roi--deriving-metrics-after-aggregation",level:2},{value:"Aggregate first, then calculate",id:"aggregate-first-then-calculate",level:3},{value:"Scenario 3: Support Ticket Analysis \u2014 Filtering Groups and Conditional Counts",id:"scenario-3-support-ticket-analysis--filtering-groups-and-conditional-counts",level:2},{value:"Counting conditional rows within a group",id:"counting-conditional-rows-within-a-group",level:3},{value:"Satisfaction Rate \u2014 percentage of tickets rated 4 or above",id:"satisfaction-rate--percentage-of-tickets-rated-4-or-above",level:3},{value:"Using <code>.filter()</code> on groups",id:"using-filter-on-groups",level:3},{value:"Common Gotchas Summary",id:"common-gotchas-summary",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"When you work with real datasets, raw rows rarely tell the story \u2014 you need to roll them up. GroupBy is how you do that."}),"\n",(0,t.jsxs)(n.p,{children:["In these scenarios the data comes in as individual transactions or records, but the business question is always at a higher level: ",(0,t.jsx)(n.em,{children:"How did each Sales Manager's team perform? Which Marketing Manager ran the most efficient campaigns? Which Team Lead resolves tickets the fastest?"})]}),"\n",(0,t.jsx)(n.p,{children:"This post walks through three of those scenarios and highlights the things that trip people up along the way."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"scenario-1-sales-performance-by-manager",children:"Scenario 1: Sales Performance by Manager"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dataset:"})," Individual sales transactions \u2014 each row is one sale, with columns for Salesperson, Sales Manager, Sale Amount, Region, Product Category, and Sale Date."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goal:"})," Produce one summary row per Sales Manager showing total revenue, number of transactions, team size, and average deal size."]}),"\n",(0,t.jsx)(n.h3,{id:"grouping-by-a-single-column",children:"Grouping by a single column"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"grouped = df.groupby('Sales_Manager')['Sale_Amount'].sum()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This gives you total revenue per manager \u2014 but it returns a ",(0,t.jsx)(n.strong,{children:"Series"})," with Sales_Manager as the index, not a column."]}),"\n",(0,t.jsx)(n.h3,{id:"grouping-by-multiple-columns",children:"Grouping by multiple columns"}),"\n",(0,t.jsxs)(n.p,{children:["When you want a breakdown by Manager ",(0,t.jsx)(n.strong,{children:"and"})," Region:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"grouped = df.groupby(['Sales_Manager', 'Region'])['Sale_Amount'].sum()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Pass a list of column names. The result now has a ",(0,t.jsx)(n.strong,{children:"MultiIndex"})," (two-level index). To flatten it back into a regular DataFrame with normal columns:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"grouped = grouped.reset_index()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"aggregating-multiple-metrics-at-once",children:"Aggregating multiple metrics at once"}),"\n",(0,t.jsxs)(n.p,{children:["Instead of calling ",(0,t.jsx)(n.code,{children:".groupby()"})," separately for each metric, use ",(0,t.jsx)(n.code,{children:".agg()"})," with a dictionary \u2014 one call, one clean result:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"summary = df.groupby('Sales_Manager').agg(\n    Total_Revenue=('Sale_Amount', 'sum'),\n    Transaction_Count=('Transaction_ID', 'count'),\n    Avg_Deal_Size=('Sale_Amount', 'mean'),\n    Team_Size=('Salesperson', 'nunique')\n).reset_index()\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Watch out \u2014 ",(0,t.jsx)(n.code,{children:"count()"})," vs ",(0,t.jsx)(n.code,{children:"nunique()"}),":"]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"count()"})," counts all non-null rows in the group"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nunique()"})," counts how many ",(0,t.jsx)(n.em,{children:"distinct"})," values exist"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you use ",(0,t.jsx)(n.code,{children:"count()"})," to measure Team Size, you'll get the number of transactions, not the number of unique salespeople. Use ",(0,t.jsx)(n.code,{children:"nunique()"}),' when the question is "how many different X".']}),"\n",(0,t.jsxs)(n.h3,{id:"as_indexfalse--when-do-you-need-it",children:[(0,t.jsx)(n.code,{children:"as_index=False"})," \u2014 when do you need it?"]}),"\n",(0,t.jsx)(n.p,{children:"By default, the column you group by becomes the index of the result:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"df.groupby('Sales_Manager')['Sale_Amount'].sum()\n# Sales_Manager is now the index, not a regular column\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"as_index=False"})," to keep it as a regular column \u2014 especially useful when you want to merge the result back into another DataFrame:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"df.groupby('Sales_Manager', as_index=False)['Sale_Amount'].sum()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively, chain ",(0,t.jsx)(n.code,{children:".reset_index()"})," after ",(0,t.jsx)(n.code,{children:".agg()"})," \u2014 same effect. Pick one and be consistent. With ",(0,t.jsx)(n.code,{children:".agg()"}),", the habit of ending with ",(0,t.jsx)(n.code,{children:".reset_index()"})," is cleaner since you're already building multiple columns at once."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"scenario-2-campaign-roi--deriving-metrics-after-aggregation",children:"Scenario 2: Campaign ROI \u2014 Deriving Metrics After Aggregation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dataset:"})," Individual campaign executions \u2014 each row is one campaign run with columns for Marketing Manager, Budget, Revenue, Impressions, Clicks, and Conversions."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goal:"})," One row per Marketing Manager showing ROI %, Click-Through Rate, Conversion Rate, and Cost Per Conversion."]}),"\n",(0,t.jsx)(n.h3,{id:"aggregate-first-then-calculate",children:"Aggregate first, then calculate"}),"\n",(0,t.jsxs)(n.p,{children:["The key insight: ",(0,t.jsxs)(n.strong,{children:["you can't calculate ROI inside ",(0,t.jsx)(n.code,{children:".agg()"})]}),". ",(0,t.jsx)(n.code,{children:".agg()"})," operates column by column. ROI needs both Revenue and Budget \u2014 two columns. So the pattern is: aggregate to get the totals, then derive the metrics on the resulting DataFrame."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"summary = df.groupby('Marketing_Manager').agg(\n    Total_Budget=('Budget', 'sum'),\n    Total_Revenue=('Revenue', 'sum'),\n    Total_Clicks=('Clicks', 'sum'),\n    Total_Impressions=('Impressions', 'sum'),\n    Total_Conversions=('Conversions', 'sum'),\n    Campaigns_Run=('Campaign_ID', 'count')\n).reset_index()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now derive the metrics on ",(0,t.jsx)(n.code,{children:"summary"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"summary['ROI_%'] = ((summary['Total_Revenue'] - summary['Total_Budget'])\n                    / summary['Total_Budget'] * 100).round(2)\n\nsummary['CTR_%'] = (summary['Total_Clicks']\n                    / summary['Total_Impressions'] * 100).round(2)\n\nsummary['Conversion_Rate_%'] = (summary['Total_Conversions']\n                                 / summary['Total_Clicks'] * 100).round(2)\n\nsummary['Cost_Per_Conversion'] = (summary['Total_Budget']\n                                   / summary['Total_Conversions']).round(2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This keeps the logic clean \u2014 aggregation in one block, derived metrics in a second block."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tip:"})," If you want formatted output (e.g., currency or percentage strings), do that as a final display step, not on the working columns. Keep the numeric columns numeric so you can still sort or filter on them."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# For display only\nsummary['ROI_%'].map('{:.2f}%'.format)\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"scenario-3-support-ticket-analysis--filtering-groups-and-conditional-counts",children:"Scenario 3: Support Ticket Analysis \u2014 Filtering Groups and Conditional Counts"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dataset:"})," Support tickets \u2014 each row is one ticket with columns for Agent, Team Lead, Resolution Time (hours), Priority (Low/Medium/High/Critical), Customer Satisfaction Score (1\u20135), and Department."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goal:"})," Team-level summary with average resolution time, satisfaction rate, and count of critical tickets handled."]}),"\n",(0,t.jsx)(n.h3,{id:"counting-conditional-rows-within-a-group",children:"Counting conditional rows within a group"}),"\n",(0,t.jsxs)(n.p,{children:["How many Critical priority tickets did each Team Lead's team handle? You can't use a plain ",(0,t.jsx)(n.code,{children:"count()"})," for this \u2014 you need to count only rows where Priority == 'Critical'."]}),"\n",(0,t.jsx)(n.p,{children:"One approach: filter first, then group:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"critical_counts = df[df['Priority'] == 'Critical']\\\n    .groupby('Team_Lead')['Ticket_ID'].count()\\\n    .reset_index()\\\n    .rename(columns={'Ticket_ID': 'Critical_Tickets'})\n"})}),"\n",(0,t.jsx)(n.p,{children:"A cleaner approach: create a flag column, then aggregate it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"df['Is_Critical'] = (df['Priority'] == 'Critical').astype(int)\n\nsummary = df.groupby('Team_Lead').agg(\n    Total_Tickets=('Ticket_ID', 'count'),\n    Avg_Resolution_Hours=('Resolution_Time', 'mean'),\n    Avg_Satisfaction=('Satisfaction_Score', 'mean'),\n    Critical_Tickets=('Is_Critical', 'sum')\n).reset_index()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The flag column (0 or 1) means ",(0,t.jsx)(n.code,{children:"sum()"})," gives you the count of matching rows \u2014 a useful pattern for any conditional count inside ",(0,t.jsx)(n.code,{children:".agg()"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"satisfaction-rate--percentage-of-tickets-rated-4-or-above",children:"Satisfaction Rate \u2014 percentage of tickets rated 4 or above"}),"\n",(0,t.jsx)(n.p,{children:"Same pattern \u2014 create a flag, then sum it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"df['High_Satisfaction'] = (df['Satisfaction_Score'] >= 4).astype(int)\n\nsummary = df.groupby('Team_Lead').agg(\n    Total_Tickets=('Ticket_ID', 'count'),\n    High_Sat_Count=('High_Satisfaction', 'sum')\n).reset_index()\n\nsummary['Satisfaction_Rate_%'] = (summary['High_Sat_Count']\n                                   / summary['Total_Tickets'] * 100).round(1)\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"using-filter-on-groups",children:["Using ",(0,t.jsx)(n.code,{children:".filter()"})," on groups"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:".filter()"})," is different from ",(0,t.jsx)(n.code,{children:".agg()"})," \u2014 it doesn't collapse groups. It returns the ",(0,t.jsx)(n.strong,{children:"original rows"})," from groups that meet a condition. Use it when you want to subset the data to only certain groups:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Keep only rows belonging to teams with avg satisfaction >= 4.0\nhigh_performing_teams = df.groupby('Team_Lead').filter(\n    lambda x: x['Satisfaction_Score'].mean() >= 4.0\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This returns a DataFrame with all the original columns \u2014 not a summary. Useful when you want to drill into high or low performing groups for further analysis."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-gotchas-summary",children:"Common Gotchas Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Situation"}),(0,t.jsx)(n.th,{children:"What to do"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Group column becomes the index"}),(0,t.jsxs)(n.td,{children:["Chain ",(0,t.jsx)(n.code,{children:".reset_index()"})," or use ",(0,t.jsx)(n.code,{children:"as_index=False"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Need distinct count per group"}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.code,{children:"nunique()"}),", not ",(0,t.jsx)(n.code,{children:"count()"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Need a metric that uses two columns (ROI, rate)"}),(0,t.jsxs)(n.td,{children:["Calculate it after ",(0,t.jsx)(n.code,{children:".agg()"}),", not inside it"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Grouped by two columns and got MultiIndex"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:".reset_index()"})," flattens it"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Need to count rows matching a condition per group"}),(0,t.jsxs)(n.td,{children:["Create a 0/1 flag column, then ",(0,t.jsx)(n.code,{children:"sum()"})," it in ",(0,t.jsx)(n.code,{children:".agg()"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Want to keep original rows for only some groups"}),(0,t.jsxs)(n.td,{children:["Use ",(0,t.jsx)(n.code,{children:".filter()"}),", not ",(0,t.jsx)(n.code,{children:".agg()"})]})]})]})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,a){a.d(n,{R:()=>r,x:()=>o});var s=a(6540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},2601(e){e.exports=JSON.parse('{"permalink":"/2025/09/13/pandas-groupby","source":"@site/blog/2025-09-13-pandas-groupby.md","title":"Pandas GroupBy in Practice: Real-World Scenarios and What to Watch Out For","description":"Practical guide to GroupBy and aggregation using business scenarios \u2014 sales performance, campaign ROI, and support ticket analysis. Covers the gotchas learners commonly hit.","date":"2025-09-13T00:00:00.000Z","tags":[{"inline":true,"label":"python","permalink":"/tags/python"},{"inline":true,"label":"data analysis","permalink":"/tags/data-analysis"},{"inline":true,"label":"learning","permalink":"/tags/learning"}],"readingTime":5.03,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Pandas GroupBy in Practice: Real-World Scenarios and What to Watch Out For","description":"Practical guide to GroupBy and aggregation using business scenarios \u2014 sales performance, campaign ROI, and support ticket analysis. Covers the gotchas learners commonly hit.","tags":["python","data analysis","learning"]},"unlisted":false,"prevItem":{"title":"My Daily Workflow with Enterprise Copilot: A Technical Writer\'s Field Notes","permalink":"/2025/10/02/copilitusage"},"nextItem":{"title":"Numpy: A Quick Reference","permalink":"/2025/08/15/numpy"}}')}}]);